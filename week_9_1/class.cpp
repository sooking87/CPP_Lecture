#include <iostream>

using namespace std;

class Negative
{
};
class Sample
{
private:
    int m;

public:
    int n;
    // Sample()
    // {
    //     m = 0;
    //     cout << "Sample() Called" << endl;
    // }
    // Sample(int x)
    // {
    //     m = x;
    //     cout << "Sample() Called" << endl;
    // }
    Sample(){};
    Sample(int x){};

    void setM(int x)
    {
        if (x < 0)
            throw Negative();
        m = x;
    }
    int getM()
    {
        return m;
    }
};

Sample::Sample()
{
    m = 0;
    cout << "Sample() is Called" << endl;
}
Sample::Sample(int x)
{
    m = x;
    cout << "Sample(int x) is Called" << endl;
}

/*
이렇게 된다면 멤버 함수에 대한 선언만 클래스에 대한 정으에 남겨두고 그거에 대한 정의는 밖으로 빼놈. 클래스 이름:: 을 통해서 Sample클래스의 sample 을 정의하는 거야. 클래스 이름에 대한 멤버 함수를 정의하는 거야 c코딩의 권장사항 자바시절에는 이렇게 코딩하지 안흔ㄴ다. 그냥 클래스 안에서 모든 멤버 함수에 대한 정의를 한다. c는 이 방법이 권장사항이다. 멤버 함ㅅ에 대한 선언만 클래스 정의에 맘겨두고 그 멤버 함수에 대한 정의는 밖으로 꺼내서 정의를 하는 ㄱ서이 구너장사항이다. 왜 극 권장 사항일가
그 이유는 c++에서는 처음에 언어가 설계될 때 오픈소스 소프트웨어 문화를 모를 때만들어진 언어이다. 소스 코드는 공개할 수 없는 것 이라는 개념이 있다. 선언만 공개를 해. 그리고 그거에 대한 정의는 기계어로 바뀐 파일 형태로 공개를 ㅏ겠다. 그래야 내 소중한 코딩의 노하우와 내용을 모를꺼니까. 내 지적재산을 보호하기 위해서 남들에게 공개대상인 선언과 공개하고 싶지 않는 정의를 분리해옴. class도 마찬가지.
class도 마찬가지 선언만 공개해주고 실제 정의를 공개하고 싶지는 않아서 분리를 한다.

선언과 정의를 다른 파일에해서 선언 부분만 .h 형태로 공개를 하고, 그 외의 실제 정의 코드는 컴파일이 완료된 기계어 코드 형태로 공유를 해준다.
*/
int main()
{
    Sample x, y, z(100);
    x.n = 1;
    y.n = 10;

    // default가 private임. 따라서 메인에서 m은 접근할 수 없어 라는 에러가 발생하낟. 그거는 클래스 내부에서만 볼 수 있음.
    // x.m = 2;
    // y.m = 20;
    // 따라서 m은 건드릴 수 없어.

    cout << "x.n: " << x.n << endl;
    cout << "y.n: " << y.n << endl;
    // 이거를 보고 싶은거는 저 n은 각각의 변ㅅ ㅇㄴ스턴스 맏 따로 잡히는 메모링 ㅣ다. x의 n과 y의 n은 다른 n이다. 이거를 보고 은 것이다.
    /*
    private은 어디에 써?
    setM이라는 함수는 public에 두었으므로 밖에서 접근 가능 SETM이라는 것은 m의 값을 초기화한다. m은 밖에 프라이빗 m을 가리키는 것이다. 이렇ㄱ 하면 뭐가 가능해지냐면 x.m은 에러가 떴었지만 x.setM(2)이런식으로 m값을 설정할 수 이싿.
    */
    x.setM(2);
    y.setM(20);
    cout << "x.m: " << x.getM() << endl;
    cout << "y.m: " << y.getM() << endl;
    cout << "z.m: " << z.getM() << endl;
    /*
    nㅇㄴ 모두 오픈, 대신 퍼블릭의 함수를 사용해서 접근이 가능하도록 하였다. 결과론 적인 동작은 똑같다.단지 public인 n은 외부에서 직접호출이 가능한데, 그렇지 않으면 우회적으로 접근이가능하다. 두가지가 다 가능은 하지만 권장되는 것은 멤버 함수를 사용해서 간접적으로 변수의 값을 초기화 해라. 멤버 함ㅅ를 만든다면 한번더 감시하는 역할을 하게 된다. 엉뚱한것으로 바꾸면 안되니까.

    함수를 이용해서 값을 만들게 된다면 함수에서 값에 대한 조건을 넣고, 거기에 맞는 값으로만 바꿀 수 있도록 만들 수 있다.
    void setM(int x)
    {
        if (x < 0)
            throw Negative();
        m = x;
    }
    예시

    따라서 권장이 되는 방식은 우회적으ㅗ 값을 설정하는 것이다. 변수는 다 private으로 외부에서 사용할 일이 있다면 별도의 멤버 함수를 만들고 access해라. 데이터의 안정성을 위해서 . 물론 귀찮겠지만. 해야됨. 내가 만든 클래스를 나 혼자 쓰는게 아님.

    멤버 함수들에는 스페셜, 이름이 정해져있는 애들이 있다.
    그중에 대표적인게 constructor이다 이거는 항상 클래스의 이름과 동일하다.
    class Sample
    {
    private:
        int m;

    public:
        Sample() {
            m = 0;
            n = 0;
        }
        int n;
        void setM(int x)
        {
            if (x < 0)
                throw Negative();
            m = x;
        }
        int getM()
        {
            return m;
        }
    };
    t생성자가 특별한 이유는 해당 오브젝트가 만들어질때 그게 디폴트로 불림. 그 함수를 호출하는 걸 프로그램이 명시적으로 호출하는게 아니라 그 오브젝트를 최초의 정의가 될 때 그때 자동으로 호출이 된다. 예를 들어서 샘플이라는 함수가 있으면 그 함수를 호출한 거는 아님. 근데 sample이라는 함수를 명시적으로 호출을 하지는 않음 근데 그걸 컴파일해서 실행해보면 sample의 생성자가 호출이 된다면 자동으로 생성자 함수를 호출한다. 즉, 인스턴스가 생성이 될 떼, 자동으로 호출되는 스페셜한 멤버 함수이다. 그래서 기본적으로 생성자는 public임.

    내가 제일 처음에 저 클래스만들대, 내가 저 m값을 입력한 값으로ㅗ 자동으로 생성하고 싶다. 매개 변수의 데이터 타입 또는 개수에 따라서 여러 가지의 함수를 사용할 수 있다는게 다형성이라는 것이다. 이 여러개의 생성자에서 파라미터가 하나도 없는 생성자를 디폴트 생성자라고 부른다.

    교수님. 아까 생성자 없었는데도 클래스 생성이 가능 했잖아요. 자동으로 호출해야되는 생성자가 생성되지 않았으니 에러 아닌가요 컴파일해보면 z만 에러. 그래서 생성자가 없게 되면 디폴트 생성자를 자동으로 만들어줌. 디폴트 생성자는 생성자가 없으면 컴파일러가 꽁짜로 만들어줌.
    Sample() {}; 이런애들 만드는 것이다. 컴파일러가 자동으로 마들어주는 것이기 대문에 x랑 y에서는 문제가 되지 않는다. z에서만 에러가 뜬거나. 그런 생성자는 없기 때문이다. default느는 그정도는 만들어줄께.

    default 만들어준까 Sample(int x)에 대한 생성자ㅏㄴ 만들고 컴파일 -> 기초 소득 을 할 수 없다. 즉 생성자가 ㅎㄴ개도 없을 때 에만 디폴트 생성자를 만들어준다.
    생성자가 한개라도 있다면 디폴트 생성자를 만들어 주지 않는다. 더이상 꽁짜는 ㅇ벗어 너가 빈털터리일때만 내가 공짜로 만들어주는거지 지금은 한개가 있잖아. 기렇게 되면 x랑 y가 에러를 띄ㅜㄴ다.

    이 이야기가 슬라이드에 나와있다.
    또 다르게 생성할 수 ㅣㅇㅆ다.
    */
}