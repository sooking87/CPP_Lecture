#include <iostream>
#include <string>

using namespace std;

/*
1. 뭘 하고 싶냐면 기존에 있던 string 클래스를 가지고 fiveString이라는 클래스를 상속받고 싶다.
*/

class FiveString : public string
{
public:
    bool solve();
    FiveString(const char *a);
    int length();
};
FiveString::FiveString(const char *a) : string(a) // -> 2. 연장 :: 저 값이 나엑 오면 안되고 나의 부모 클래스로 보내야돼. 저 초기황 대한 내가 할일이 아니라 나의 부모인 String 클래스가 처리행댜될 일이다. paraend 클래스를 호출할 수 있는 방법이 있다. 그 방법이 뭐야? 함수 뒤에 string(a)가 있다. a에 대해서 나는 할일이 없는데 a에 대한 처리를 부모 클래스인 생성자가 해주세요. string(a)는 내가 처리할게 안리ㅏ 나의 부모 클래스인 string 클래스의 생성자가 처리해 줄것이다. 라는 것이다. 내가 만들어질때, 나만 만들어지는게 아니라 부모도 만들어진다. 내가 부모거를 물려받아야되니까. 내 안에 부모 클래스가 있어,,,,,,,,,,,,,,,,,,, 쏘잉맨이라는 것은 에니메이션에서 몬스터 강아지를 키운다. 그 몬스터 강아지는 사람이 죽을 때 그 몬스터 강아지가  내가 부모 클래스를 상송받아서 가지고 있다는게, 진짜로 내 안에 부모 오브젝트가 있다. 그 위에 추가로 있는 형태가 된다. fiveString이라는 객체를 메인함수에서 만드는 순간. fivestring이 만들어진 것 같지만 실제로 그 안에는string 클래스가 만들어진다. 그  위에 얇게 fiveString이 덧씌워져서 만들어진 것 뿐이다.

// fiveString의 마이라는 생성자가 호출 될때 부모 클래스의 ㅐㄱ체도 만들어 져야되므로 부모 클래스의 생성자도 불리게 된다. 그런데 내가 명시적으로 부모의 여러 생성자 중에서 누구를 부를지를 명시하지 않으면 부모의 디폴트 클래스가 기본적으로 불려진다. 내가 원하는게 디폴트가 아니라 명시적으로 부모 클래스를 선택할 수 있다. 그 선택할 수 인느 문법이 `: 부모클래스 이름(파라미터)` -> 이렇게 된다면 원래 string이 char 받는 생성자가 있고, 그 생성자를 명시적으로 호출해준 것이다. 나는 solve만 추가된 것이다.
{
    ;
}
// 5.1 이건 오버 라이드. 함수의 형식 파라미터 개수, 타입이 같기 때문에
// 이렇게 원하는 것만 쏙쏙 뽑아서 수정할 수 있다.
int FiveString::length()
{
    return string::length() * 2;
    // 5.2 return length() * 2 이렇게 만 쓰게 된다면 가장 가까운 length를 사요하기 때문에 ㄱ{속 자기 자신에 대한 length를 호출하게 된다. 따랏 명시적으로 String 클래스의 length라는 것을 알려주어야 되므로 string::length()라고 사용을 해야되는 것이다.
    // 5.3 한땀한땀 구현하는 것은 시간이 너무 오래걸려 그 소스코드를가지고 있냐 아니냐는 중요하지 ㅇ낳어. 내가 필요로 하는것만 적당히 추가하고 적당히 오버라이딩하면 내가 원하는 클래스를 사용할 수 있다.
}
bool FiveString::solve()
{
    int len = string::length(); // 3. 원래 string 클래스에 legnth가 있어
    if (len == 4 || len == 6)
    {

        for (int i = 0; i < 10 && (*this)[i] != '\0'; i++) //(*this)[i] string클래스는 []에 대한 정의를 해놓았는데, 그 []연산자에 대한 거는 어떻ㄱ 쓰지 나는 안해놓았어도 내 부모는 해놓은 그걸 가져다 쓰고 싶어. 나에 대해서  [] 연산자를 쓰고 싶다. *를 하게 되면 포인터가 아니라 나 자신의 값이 된다. *this에 []를 붙히면 부모 클래스가 정의해놓은 [] 연산자를 활용할 숭 ㅣㅆ다.
        {
            if ((*this)[i] < '0' || (*this)[i] > '9')
            {
                return false;
            }
        }
    }
    else
    {
        return false;
    }
    return true;
}
int main()
{
    FiveString my("123456");                                       // 2. d왼쪽 자리가 fivestring my = "!2345" 이라면 five String이 = 에 대한 오버로딩을 해줘야 되는데 안해놓아서 에러가 떴고, 그래서 오퍼레이터 오버로딩은 사용하지 않고 생성자를 사용했다.
    cout << my.length() << ":" << my << ":" << my.solve() << endl; // 4. 그리고 나는 cout에 대한 오버로딩도 안해놨는데, 출력은 된다?? 저게 잘되는 이유는 cout이 string에 대해서는 구현이 되어ㅣ있기 대문이다. 내 안에 진짜 부모의 객체가 있는데, 실제 동작할때에는 그걸 뚫어봐. 그래서 그걸 string 취급을 해준다. 무조 클래스인 척 할 수 있다. 근데 반대는 안돼 부모 클래ㅡ는 자식 클래스인 척 할 수 없다. 하지만 자식 클래스는 부모 클래스인 척 할 수 있다. 그 안에 진짜로 부모 객체가 있기 때문에 그래서 여기서 이게 동작하는 이유ㄴ는 my를 string이라고 생각하고 처리해주는 것이지 FiveStinrg이라ㅗㄱ 처리해주는 것은 아니다. 우리는 string 클래스의 소스코드가 없다. 근데 마음대로 string 클래스를 확장했다. -> 이런게 가능해지고, 이게 상속의 힘이다.
    return 0;
}