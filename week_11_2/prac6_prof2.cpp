#include <iostream>

using namespace std;

// class 에 집중해서 보자
class Polygon
{
protected:
    int m, n;

public:
    Polygon(int m, int n);
    // virtual void draw() = 0; // 1. draw 함수는 구현을 안할거라는 말을 해주는 것이다.  구현하지 앟을 거를 왜 적어죠? 나중에 설명해줄것 여기서 draw라는 것은 선언을 굳이 부모 클래스에 넣어둔 의미가 뭘까 draw라는 것은 Polygon에서는 정의를 하지 않는 다고 했다. 그냥 선언만 넣지 정의는 없을거라는 것을 미리 선언. 근데 이걸 왜 굳이 만들어? draw를 넣는 장점은 두가지 큰 장점이 있는데 첫 번재 장점은 -> 사례 (1)
    // void draw(); // 1 연장 222 이렇게 구현할 수도 있다. 하지만 아까와의 차이는 명시적으로 자식 클래스에게 구현에 대한 의무를 줌.
    virtual void draw(); // 2번째 장점: 자식의 객체를 만들어진다ㅁ는 것은 부모 객체 위에 덧붙혀져서 만들어진다. 자식을 바라볼때 부모라고 생각하고 봐라봐도 아ㅜ 문제 없다. 이걸 이용해서
    virtual ~Polygon();
};
void Polygon::draw()
{
    cout << "default" << endl;
}
class Rect : public Polygon
{
public:
    Rect(int m, int n);
    void draw(); // 오버 라이드
    ~Rect();
};
class Triangle : public Polygon
{
public:
    Triangle(int m, int n);
    void draw(); // 오버 라이드
    ~Triangle();
};
Polygon::Polygon(int m, int n)
{
    this->m = m;
    this->n = n;
}
Polygon::~Polygon()
{
    cout << "Polygon::~Polygon()" << endl;
}
Rect::Rect(int m, int n) : Polygon(m, n)
{
}
Rect::~Rect()
{
    cout << "Rect::~Rect()" << endl;
}
void Rect::draw()
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cout << "*";
        }
        cout << endl;
    }
}
Triangle::Triangle(int m, int n) : Polygon(m, n)
{
}
Triangle::~Triangle()
{
    cout << "Triangle::~Triangle()" << endl;
}
void Triangle::draw()
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < i; j++)
        {
            cout << "*";
        }
        cout << endl;
    }
}

int main(void)
{
    int a;
    int b;
    int type;
    cin >> type >> a >> b;

    // 장점 2를 ㅂ알아보기 위한 콛, 작성
    Polygon *pol;
    if (type == 3)
    {
        pol = new Triangle(a, b);
    }
    else if (type == 4)
    {
        pol = new Rect(a, b);
    }
    pol->draw();
    delete pol; // 여기서 하고 싶은게 뭐냐면 폴리곤의 포인터야 타입을 사용자로부터 ㅂ다아서 사용자가 삼각형을 원하면 3입력 Triangle new해서 가르키게 할 꺼야. 어차피 폴리곤은 폴리곤의 포인터인데, 트라이앵글을 포인터로 가리키는데 아무런 문제가 없다. 사각형ㄷ ㅗ상관ㅇ 벗이 Rect 안에 폴리곤이라는 오브젝트가 있기 때문에 따라서 이게 가능하다. 부모 클래스의 개체를 항상 자식 클래스가 가지고 ㅇ;ㅆㅇ므로 이를 가리키는데 아무런 문제가 없다. triangle을 가르켜도 아무런 문제강 벗다. 근데 실제로는 rect, tri안에 있는 폴리곤을 보고 있는 것이ㅏㄷ. 그냥 폴리곤으로 생각하겠다. 이런 마인드. 이걸 돌리면 되면 default가 찍혀. 사실 너무 당연해. 실제로 폴리곤을 가르키므로. Rect의 draw가 호출되기를 기대하만 실제론ㄴ 폴리곤을 가리키는 것이므로 폴리곤의 draw가 호출되는 것이다... 당연한 결과이다. 근데 항상 default로 출력되면 삼 사각형 클래스 애 만들어? 이거를 해결하기 위한 방법: 우리가 실제로 포인터가 삼각형이 될지, 사각형이 될지 는 런타임시에 결정된다. 실제 실행하고 나서 그 클래스가 결정된다. 실제로 어떤 함수가 불려야되는지 는 컴파일 타임에 결정되므로 draw 함수는 폴리곤꺼의 draw가 도니다. 이러한 상속을 극대화하기 위해서 이러한 코딩에서는 실제 객체의 오버라이드된 함수를 부록고 싶을 수 있잖아! 그래서 문법을 추가했다. virtual이라는 문법이 추가된다.......... 헐 ㄹㅇ 대박 virtual void draw()로 ㅎ게 된다면 그냥 빈칸으로 비웢두고 런타임시에 결정할거라고 말해주는 것이다. 그 오브젝트가 오러라이드 한 함수를 찾아서 불러주겠다는 것이다. virtual를 부르게 되면 컴파일 링킹 타임에 결정 그런데 virtual이라고만 붙히면 컴파일 링킹 타임에 함수 결정하지 않아. 런타임 시에 결정. 그 실제 포인터가 가리키는 원래 오브젝트를 오버라이드 한 함수를 쫒아가서 불러주자. 이러한 함수를 virtual 함수라고 부른다. 이러면 상속의 효과가 배가 된다. 와씨 대박. 상속의 힘 => 어떤 개체를 만들지 모르는데 언제 어떻게 만들지 모르겠느데 이런거를 공통적으ㅇ로 그림을 그리는 함수를 만들고 싶어. virtual인지 그냥 함수인지를 선택할 수 있게 한ㄷ. 자바에서는 철학이 자유를 주지 않는다. 무조건 virtual로 통일. 자바는 virtual 이 없어. 모든 함수가 다 virtual 이므로 자바에서는 virtual 키우드가 존재하지 않는다. virtual이 없는게 조금 더 빨라 . 수행 시점에는 virtual 아닌게 더 빠르긴 함. c++에서는 호율이 중요하므로 나머지는 일반적으로 정의를 하고 딱 virtual이여야되는 것만 함술ㄹ 만들 수 있다.
    /*
    베이스 클래스는 상속에 대해서 가이드라인을 잡는다.
    {2번째 장점 이후} 한 번 더 나아가서. delete pol이 있다. 이거는 매우 자연스러운 일이다. 메모리를 반환한건데, pol을 딜리트했는데, 여기서 소멸자 얘기를 잠깐 할껀데ㅐ 4 5 3 W찍힌거 ㅁ보니가Rect 클래스가 만들어졌느데 폴리콘 소멸자만 불렸다. 이거는 아까랑 얘기가 똑같아. 개체가 없어질 때 호출해야되는 소멸자를 컴파일 링킹 타임에 결정할 수 박에 없어. 딜리트 할 때는 폴리곤으로 ㅏㄹ 수 밖에 없어. Rect은 안불려? 그러면 불리고 싶으면 소멸자를 virtual로 만들어야 된다. 이렇게 하면 Rect를 소멸하고, 폴리곤을 소멸하는데, 이것도 virtual 때문인건가? 지난 시간에는 높은 클래스부터 차곡차곡 사라진다고 했던 것 같은데 ???????????
    */
    /*
    질문 1. virtual 소멸자 부분 -> Rect를 소멸하고, 폴리곤을 소멸하는데, 이것도 virtual 때문인건가? 지난 시간에는 높은 클래스부터 차곡차곡 사라진다고 했던 것 같은데 ???????????
    질문 2. void draw() = 0 -> 추상 클래스 만들기, virtual void draw(); -> 런타임시의 함수를 결정 <-> 근데 아까 void draw() = 0만 했을 때 안되는 이유?
    질문 3. 다형성 => 가상 함수 , 함수 템플릿 , 함수 오버로드 , 연산자 오버로드로 구현한다.. 다형성: 개념은 하나인데, 형식이 다양하다.
    */

    /**/
    // Polygon pol(a, b);
    // pol.draw(); -> 1. 연장 pol.에는 draw가 없어서 안부른 것 -> 여기서 에러가 뜬 이유는 이게 0이라서 에러가 뜬 것이라는 것이기 보다는 멤버 함수에 선언만하고 정의를 안하는 것을 추상 클래스라고 부른다. 그래서 우리가 추상 클래스라고 하는 것은 정의가 없고 선언만 있는 멤버 함수가 존재하는 클래스를 추상 클래스라고 한다. 근데 이러한 추상 클래스는 인스턴스를 만들지 못해 = we cannot create instances objects of it = 즉 Polygon이라는 클래스를 사용할 수 없다. Polygon 클래승에 대해서 인스턴슬ㄹ 만들 수 업삳. 멤버 함수가 없기 때문에ㅐ 그럼 나쁜거 아니야? 이게 Polygon이 아니라 Rect면 문제가 ㅇ벗어
    Rect rect(a, b); // REct로 하면 아무 문제가 없는데 Polygon이라고 하면 에러가 뜬다.그 이유는 Polygon은 추상 클래스이기 때문이다. 추상 함수가 없는게 좋은 겅 ㅏ니야? -> 이대는 Polygon 클래스도 인스턴스르 만들 수 있어 . 근데 이렇게 되면 Rect의 draw가 오버라이드가 아니야 부모 클래스에 없기 때문에 이렇게 만들면 Polygon도 인스턴스 만들 수 있으므로 Rect도 돌아가므로 더 좋은 것 아니야? 근데 아니야 왜? 우리가 여기에 이러한 가상함수를 만들게 되면 이 모적은 자기가 그것을 구현해서 인스턴스를 만들고자 하는게 목적이 아니라 훗날 상속받을 클래스에 의무를 나열하는 것이다. 나를 상속받은 클래스는 반드시 draw 함수를 가지고 있어야 한다라는 의무를 넘기게 된다. Polygon 클래스가 가상 함수를 가지고 있을 대, Rect가 draw를 구현하지 않는다면 에러가 ㄸ게 된다. Rect는 폴리ㅋ곤을 상속받아 그렇다는 것은 가상 함수(선언은 있고 정의만 없는 함수도 상속 받는다. ) 따라서 Rect는 여전히 자기의 인스턴스를 만드맂 못해 draw를 오버라이드 하지 않는한. 따랏 추상 클래스에 대한 함수 정의가 존재하지 않는 함수를 오버라이드 하지 않는 이상 자식 클래스도 인스턴스를 만들지 못함. 따라서 부모 클래스가 반드시 오버라이드에 대한 의무를 지우게 된다. 만약에 폴리곤 그로우를 넣지 않는다면 상속받은 클래슨느 draw 정의에 대해 자유가 된다. 하지만 부모 클래스에 가상 함수를 정의해놓으면 자식 클래스는 반드시! 정의를해야된다. 이게 첫 번재의 추상 클래스 효과이다. 그러다 보니까 항상 상속을 염두해두고 설곟ㄴ다. 앞으로 어떻게 될지ㅡㄴ 내 자식 클래스의 자윤데, 어ㄸㅎ게 draw 할지는 자식 클래스 자유지만 아무튼 draw 함수는 반드시 구현해서 가지고 ㅇㅆ어야 된다. 따라서 항상 상속을 염두해 둔다. 자기를 사속받은 클래스가 잇을 것을 염두 = 그래서 피피티에 Base 클래스 라고 나온 것이다. 보편적인 용어에서는 그냥 추상 클래스라고 쓴다. 추상적인 명세만 나열했지 실질적인 구현에 대해서는 오픈되어 있다 그래서 추상 클래스라고 부름. 자바는 추상 클래스를 허용하지 않는다. c++에서는 추상 클래스에서 추사 함수랑 그냥 하수랑 섞을 수 있다. ㅈ=근데 자바는 한번에 추상 함수들을 빼서 모아놓은 애를 인터페이스라고 부른다. 인터페이스를 쓰면 단 하나의 멤버 함수도 정의가 잇으면 안된다. 추상 ㅎ마수가 하나라도 있으면 무조건 추상 클래스 라고 하낟. 첫 번째 장점!

    rect.draw();
    return 0;
}
