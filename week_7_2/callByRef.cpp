#include <iostream>
#include <vector>

using namespace std;

// void test1(int a) // call by value라는 것
// {
//     a++;
// }

// void test2(int &a) // & 라는 것은 call by ref라는 것
// {
//     a++;
// }

void test1(vector<int> a) // call by value라는 것
{
    a.push_back(100);
}

void test2(vector<int> &a) // & 라는 것은 call by ref라는 것
{
    a.push_back(100);
}

int main()
{
    // int i = 0;
    // int j = 0;

    vector<int> i;
    vector<int> j;
    test1(i);
    test2(j);

    cout << "i.size(): " << i.size() << endl; // 0
    cout << "j.size(): " << j.size() << endl; // 1
}

/*
i는 0, j는 1
그 이유가 뭐냐면 test1의 i는 0이라는 ㄱ밧을 복사해서 test1의 in a에 복사로 전달해준다. 따라ㅓㅅ main의 i의 값에는 아무런 영향을 미치지 않는다.
두번째는 ref이기 때문에 j랑 a가 또같은 주소가 된다. 그ㅐ럿 test2에서 a++라는 것은 j의 가시 변경되는 효과가 있다.
cout을 통해서 i를 찍으면 0이 되고, j를 찍으면 1이 되는 것이다.

test1에서 push)back을 하는 것은 메인에 있는 아이랑 소용이 없다.
j랑 a가 같은 백터가 된다. 메모리를 전달하기 때문이ㅏㄷ. test2에서 푸시 백을 해주는 것은 j에 해주는 것과 똑같은 효과를 가질 수 있다.

만약에 i벡터가 값을 1000개 가지고 있고, j도 마찬가지라고 한다면 test1은 함수 호출 단계에 1000개의 데이터를 복사해 주어야 한다. 따라서 함수 호출의 시간이 오래걸린다.
test2의 경우는벡터에 대하 복사를 하지 않는다. 10000개의 갑세 복사가 없다. 함수 호출에 대한 시간이 빠르다. 대신 안정성은 떨어진다. 의도하지 않은 벡터 j에 대한 변경을 하게 되면 고스란히 j에 영향을 미침. 그게 의도한 변화면 상관이 없는데, 의도하지 않은 변화라면 이를 막을 방법이 없다. 상대적으로 test1은 안정서은 좋다. 아무리 벡터를 가지고 오만짓을 해도 vector i에는 아무런 영향이 없으니까 호출하는 시점에서는 구분이 되지 않는다. 어떤게 ref고 value인지는 알수없다 매개변수를 봐야 ref인지 value인지를 알 수 있다.

call by ref 장 1: 그 값을 바꾸는게 원래 나의 의도야 -> 그럴때는 함수를 믿고 ref를 불러와야 되는데, 2번재 장점이 ㅏ꾸는게 목적은 아닌데 함수 호출 시점에서 값을 복사하는 시간이 아까운 경우 그래서 ref를 사용하고 싶어 이런 경우는 나의 이ㅡ도가 값을 바꾸는 걸 바꾸는 것은 아닌데 단지 복사하는 시간이 아까울 뿐이야 . 이때에는 한가지 안전장치가 있다. 그게 뭐냐면 피피티 23쪽, 앞에다가 const를 붙여주면 컴파일러에게 값 변경시 에러를 띄운다. 값 보가하는 것을 시간이 아까워서 그런거라서 값을 바꾸는 것은 의도가 아니야 그래ㅓㅅ 값을 바꾸게 된다면 컴파일러 너가 에러를 띙워줘야돼!

void test2(const vector<int> &a) // & 라는 것은 call by ref라는 것
{
    a.push_back(100);
}

-> 컴파일 에러 발생: 선언에 const라는 것을 통해서 안정성을 보장해줄 수 잇다. refㅇ 대한 변수에 대한 변경 시도가 잇따면 에러를 띄워준다. 안전 ㅈ아치로 const가 있다. 이거를 항상쓰는 것은 아니다 . 사실 값을 바꿔주기를 원할 때도 있기 때문에 그럴 경우는 어쩔 수 없이 func가 적절히 기능을 한다고 믿어야 된다.
*/